import React from 'react'
import { getPayload } from 'payload'
import config from '@/payload.config'
import { notFound } from 'next/navigation'
import { ContentSection } from '@/components/blog/ContentSection'
import { RelatedNews } from '@/components/blog/RelatedNews'
import { Introduction } from '@/components/blog/Introduction'
import { BlogMeta } from '@/components/blog/BlogMeta'
import type { Post, Category, Media } from '@/payload-types'

interface BlogPostPageProps {
  params: Promise<{
    slug: string
  }>
}

export const dynamic = 'force-static'

export async function generateMetadata({ params }: BlogPostPageProps) {
  const { slug } = await params
  const payload = await getPayload({ config })

  const { docs } = await payload.find({
    collection: 'posts',
    where: {
      slug: { equals: slug },
    },
    limit: 1,
    depth: 2,
  })

  const post = docs[0] as Post | undefined

  if (!post) {
    return {
      title: 'Post Not Found',
    }
  }

  const ogImage = post.seo?.ogImage as Media | undefined
  const featuredImage = post.featuredImage as Media

  return {
    title: post.seo?.metaTitle || post.title,
    description: post.seo?.metaDescription || post.excerpt,
    keywords: post.seo?.keywords?.map((k) => k.keyword),
    openGraph: {
      title: post.seo?.metaTitle || post.title,
      description: post.seo?.metaDescription || post.excerpt,
      images: ogImage?.url || featuredImage?.url ? [ogImage?.url || featuredImage.url] : [],
    },
    twitter: {
      card: 'summary_large_image',
      title: post.seo?.metaTitle || post.title,
      description: post.seo?.metaDescription || post.excerpt,
      images: ogImage?.url || featuredImage?.url ? [ogImage?.url || featuredImage.url] : [],
    },
    ...(post.seo?.canonicalURL && { alternates: { canonical: post.seo.canonicalURL } }),
    ...(post.seo?.noIndex && { robots: { index: false, follow: false } }),
  }
}

export default async function BlogPostPage({ params }: BlogPostPageProps) {
  const { slug } = await params
  const payload = await getPayload({ config })

  const { docs } = await payload.find({
    collection: 'posts',
    where: {
      slug: { equals: slug },
      status: { equals: 'published' },
    },
    limit: 1,
    depth: 2,
  })

  const post = docs[0] as Post | undefined

  if (!post) {
    notFound()
  }

  // Extract tag IDs and category ID for related posts
  const tagIds = post.tags
    ? (post.tags as any[])
        .map((tag) => (typeof tag === 'number' ? tag : tag.id))
        .filter(Boolean)
    : []

  const categoryId =
    typeof post.category === 'number' ? post.category : (post.category as Category)?.id

  // Fetch related posts
  const relatedPostsQuery = await payload.find({
    collection: 'posts',
    where: {
      and: [
        {
          id: {
            not_equals: post.id,
          },
        },
        {
          status: {
            equals: 'published',
          },
        },
        {
          or: [
            categoryId
              ? {
                  category: {
                    equals: categoryId,
                  },
                }
              : {},
            tagIds.length > 0
              ? {
                  tags: {
                    in: tagIds,
                  },
                }
              : {},
          ],
        },
      ],
    },
    limit: 4,
    depth: 2,
  })

  const relatedPosts = relatedPostsQuery.docs as Post[]

  return (
    <>
      <Introduction />
      <BlogMeta post={post} />
      <ContentSection post={post} />
      <RelatedNews posts={relatedPosts} selectedPost={post} />
    </>
  )
}

export async function generateStaticParams() {
  const payload = await getPayload({ config })

  const { docs: posts } = await payload.find({
    collection: 'posts',
    where: {
      status: { equals: 'published' },
    },
    limit: 1000,
  })

  return posts.map((post) => ({
    slug: post.slug,
  }))
}
